# 进程与线程的比较
- 进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。
- 进程有自己独立的地址空间，多个线程共用某一个进程的地址空间。
- 在一个地址空间中多个线程独享：每个线程都有自己的栈区
- 在一个地址空间中多个线程共享：代码段，全局数据区，堆，文件描述符表(也就是进程fd文件夹下的)
- 每个进程对应一个虚拟地址空间，一个进程只能抢一个时间片
- 一个进程可以划分出多个线程，在有效资源的基础上，可以抢到更多的cpu 时间片。
- 线程的上下文切换比进程快的多。所谓上下文切换：进程和线程分时复用 cpu 时间片，在切换之前会将上一个任务的状态保存，下次切换回这个任务的时候，加载这个状态继续运行。任务从保存某个状态到再次加载这个状态这个过程就是一次上下文切换。
- 线程更加廉价，启动速度快，退出也快，对资源的冲击小。
- 进程，就是应用程序被操作系统调入内存，分配合理的资源，并给予足够的时间片，切实开始运行的程序生命体。
- 线程有独立的时间片，可以独立运行。
- 线程不能开的太快，即不能在一个循环中快速启动进程，否则很可能开出死线程，即这个线程系统已经认为存在了，但没有获得时间片，实际上永远都不会运行。
- 线程永远不能在外部被杀死，容易导致资源泄漏，原则上是设置一定的条件，让线程函数自行返回。
- 线程的总数有限制，最多只能控制在 300 左右。
- 线程是后启动的，即一个函数开启线程，很可能这个函数已经退出了，但线程还没有获得第一次可运行的时间片，因此，给线程传参的时候，需要使用“远堆传参”。
- 多任务环境所有的同步等待动作，一定是以牺牲效率为代价的。
- sleep() 的合理使用，可以释放时间片资源，降低 cpu 占用率。
- 为解决多线程退出时的协同退出问题，即在主进程退出之前，所有的子进程已经退出，可以使用多线程安全变量来完成。一个是 bool 变量，这是所有线程可以持续运行的标志，另一个是 int 变量，这是所有线程的计数器。
- 类中的线程函数必须是静态的。

# 跨进程通信
- 可以使用有名管道和无名管道
- 可以使用信号量，共享内存区，内存映射区
- 但是为了部署的方便，和最大的灵活性：统一使用基于 tcp/ip 协议的 socket 传输作为进程间通信的手段。

# 同步异步
- 异步最大好处就是高效率，使资源的利用率最大化。
- 提升服务器性能的措施：拆分业务，将每个业务都差分成单一的服务，然后通过异步运算，提升服务器集群的性能。
- 异步转同步也是不可避免的，其有一个很大的隐患，就是由于等待造成网络延时叠加，最好的解决办法就是避免请求等待叠加，尽量使服务器集群扁平化。
- 异步转同步最常用的工具就是锁。

# 你以为的锁
- 使用锁，是不同线程访问相同资源的必要条件。
- 绝大多数锁的使用，其实是和资源相关的，一个资源，一旦有跨线程访问需求，就需要加锁。
- 正确的做法是把锁和资源绑定到一起，利用 C++ 类封装特性，将资源私有化，同时所有的公有方法，全部内部实现加锁访问，这样，所有的访问都是线程安全的，这就是资源锁。但是这样会存在一个问题，当一个公有方法要调用另一个公有方法的时候，会引发重复加锁的错误。
- 最好的资源锁实现方式是：将一个线程安全类显示分为两块逻辑，一块专门管功能实现，另一块专门管安全加锁，实际书写时，先写一个基类实现所有功能，但是不加锁，另外再写一个聚合类来包容基类，聚合类的公有方法和基类完全一模一样，只做加锁动作。
- 单写多读锁，当为读锁时，所有的写操作被悬停等待，而读请求被允许通过，当为写锁时，所有的操作被悬停。并且，读写切换时，有足够的等待状态，直到真正安全时，才会切换动作。
- 用锁的最高境界，就是不用。锁其实是为了解决并发访问时，乱序写动作造成的数据不一致问题。

# 你以为的池
- 池的使用不应该在一开始就设计，应该在白盒测试阶段才引入池优化，这样就可以有一个性能参数供参考。先解决有无问题，再解决好坏问题。

# 跨平台，跨平台，跨语言开发基础
- 商用工程设计，永远是至上而下的设计模式，即根据需求，先选择平台，再选择语言，再决定解决方案。
- 
